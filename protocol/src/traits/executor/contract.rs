use crate::traits::executor::{ContractSchema, InvokeContext};
use crate::types::{Address, Asset, AssetID, Balance, ContractAddress, MerkleRoot};
use crate::ProtocolResult;

pub trait ContractStateAdapter {
    fn get<Schema: ContractSchema>(
        &self,
        key: &Schema::Key,
    ) -> ProtocolResult<Option<Schema::Value>>;

    fn contains<Schema: ContractSchema>(&self, key: &Schema::Key) -> ProtocolResult<bool>;

    fn insert_cache<Schema: ContractSchema>(
        &mut self,
        key: Schema::Key,
        value: Schema::Value,
    ) -> ProtocolResult<()>;

    fn revert_cache(&mut self) -> ProtocolResult<()>;

    fn stash(&mut self) -> ProtocolResult<()>;

    fn commit(&mut self) -> ProtocolResult<MerkleRoot>;
}

/// BankContract is the registration and query center for asset.
///
/// It only does two things
/// 1. Responsible for generating a unique ID for the asset and writing the
/// asset's information to the chain.
/// 2. Query the basic information of the asset by asset id.
pub trait BankContract<Adapter: ContractStateAdapter> {
    // Register an asset.
    // The asset id is generated by: AssetID = Hash(ChainID + AssetContractAddress).
    //
    // NOTE: After the asset is successfully registered, the `world state` will not
    // be modified unless `commit` is called.
    fn register(
        &mut self,
        ictx: InvokeContext,
        address: ContractAddress,
        name: String,
        symbol: String,
        supply: Balance,
    ) -> ProtocolResult<Asset>;

    fn get_asset(&self, ictx: InvokeContext, id: &AssetID) -> ProtocolResult<Asset>;
}

pub trait AccountContract<Adapter: ContractStateAdapter> {
    fn transfer(
        &mut self,
        ictx: InvokeContext,
        id: &AssetID,
        amount: Balance,
        from: &Address,
        to: &Address,
    ) -> ProtocolResult<()>;

    fn get_balance(
        &self,
        ictx: InvokeContext,
        id: &AssetID,
        address: &Address,
    ) -> ProtocolResult<Balance>;
}
